java高并发的核心知识点：
- 多线程
- 线程池
- 锁(java内置锁\juc显式锁)
- JMM(内存模型)
- CAS
- JUC(并发组件)
- AQS(抽象同步器，模板方法设计模式，并发组件实现的基础)
- 高并发设计模式


# 1 多线程、线程池核心原理及实战；线程安全问题；java内置锁的核心原理

进程
```text
进程是操作系统资源分配的最小单位。

进程是程序的一次启动执行，程序可以启动多次，可以对应多个进程，比如chrome浏览器，多个网页对应多个chrome进程。

应用程序以进程的形式运行在OS上。
一般来说，进程包含程序段，数据段和进程控制块3部分。

程序段：代码指令集合在内存中的位置
数据段：操作数集合在内存中的位置
控制块：进程的描述信息和调度信息等

Java进程：
每次启动一个java进程，都会启动一个jvm进程，进程内都是以多个线程来执行，程序入口进去是主线程。还要一个必须的GC线程(守护线程)。

```
![](./image/进程基本结构.PNG)

线程
```text
线程是CPU调度的最小单位。

CPU时间片调度算法（抢占式获得cpu时间片）

一个线程主要是3部分：线程描述信息，程序计数器（program counter PC）和栈内存

线程ID，一个进程内的thread id不会重复，JVM管理

thread name，可以指定，不指定系统自动分配

线程优先级，只是一种标识，不一定有效，不同系统优先级别不一样，默认1-10，5


线程状态，新建，就绪，运行，阻塞，结束

其他属性，是否是守护线程等

程序计数器，记录的是线程下一条指令的内存地址

栈内存里包含了栈需要的局部变量和方法的栈帧，栈私有，jdk8中，每个线程创建时默认分配1M大小的内存（golang的协程更加轻量级）。

栈内存和堆内存不同，不受GC管理。
```
![](./image/线程的基本结构.PNG)

```java
System.out.println("current thread name: " + 
Thread.currentThread().getName());

System.out.println("current thread id: " + 
Thread.currentThread().getId());

System.out.println("current thread status: " + 
Thread.currentThread().getState());

System.out.println("current thread priority: " + 
Thread.currentThread().getPriority());
```

进程和线程的区别：
```text
1. 一个进程里有多个线程，至少有一个线程
2. 线程是CPU调度的最小单位，进程是OS分配资源的最小单位
3. 进程间互相独立，进程内部的线程可以共享资源
4. 线程上下文切换代价小于进程上下文切换
```

创建线程的4种方式：
```java
// java.lang.Thread
/**
Thread(String name)
Thread(Runnable target)
Thread(Runnable target, String name)

int getId()
String getName()
void setName(String name)
int getPriotity()
void setPriority(int)

static Thread currentThread()
static void sleep(long millis)

void setDaemon(boolean on)
boolean isDaemon()

void start()
void run()

void join()
void join(long millis)
void join(long millis, int nanos)
boolean isAlive()

static void yield()
static void sleep()
*/

public static final int MIN_PRIORITY = 1;
public static final int NORM_PRIORITY = 5;
public static final int MAX_PRIORITY = 10;

public static enum State {
    NEW,            // 新建
    RUNNABLE,       // 就绪，运行
    BLOCKED,        // 阻塞
    WAITING,        // 等待
    TIMED_WAITING,  // 超时等待
    TERMINATED;     // 结束
}

private Runnable target;
public void run() {
    if (this.target != null) {
        this.target.run();
    }
}

// start()启动一个线程
// run()线程逻辑的执行入口函数
```

1. 继承Thread
```java
Thread t = new Thread();
System.out.println(t.getName()); // Thread-0
t.start();

class T extends Thread {
    T(String name) {
        super(name);    
    }
    @Override
    public void run() {
        System.out.println(super.getName()+" running...");
    }
}
T t1 = new T("t1");
t1.start();
```

2. 实现Runnable
```java
// java.lang.Runnable
package java.lang;
@FunctionalInterface
public interface Runnable {
    void run();
}

class Run1 implements Runnable {
    public void run() {
        System.out.println(Thread.currentThread().getName()+" running...");
    }
}
Thread t2 = new Thread(new Run1, "t2");
t2.start();

// 匿名内部类的方式
Thread t3 = new Thread(new Runnable() {
    public void run() {
        System.out.println(Thread.currentThread().getName()+" running...");
    }
});
t3.start();
// lambda方式
new Thread(() -> {
    public void run() {
        System.out.println(Thread.currentThread().getName()+" running...");
    }
}).start();
```

Thread和实现Runnable接口的不同：
Runnable接口可以更好的逻辑和数据分离
```java
import java.util.concurrent.atomic.AtomicInteger;

public class T1 {
    public static final int num = 5;
    public static void main(String[] args) {
        // 2个卖，每个都有5个
        /*for (int i=1;i<=2;i++) {
            new Inner1("worker "+i).start();
        }*/
        // 2个卖，总共5个
        Inner2 inner2 = new Inner2();
        for (int i=1;i<=2;i++) {
            new Thread(inner2, "worker "+i).start();
        }

    }
    static class Inner2 implements Runnable {
        private AtomicInteger in = new AtomicInteger(num);
        @Override
        public void run() {
            for (int i=0;i<=num;i++) {
                if (in.get() > 0) {
                    System.out.println(Thread.currentThread().getName()
                            +" sold one, left " + in.decrementAndGet());
                }
            }
        }
    }
    static class Inner1 extends Thread {
        Inner1 (String name) {
            super(name);
        }
        private int sum = num;
        public void run () {
            for (int i=0;i<=num;i++) {
                if (sum > 0) {
                    System.out.println(getName()+" sold one, left " + (--sum));
                }
            }
        }
    }
}
```

3. 使用Callable接口和FutureTask类创建带返回值的线程

Thread类和Runnable接口的run()没有返回值

```java
package java.util.concurrent;
@FunctionalInterface
public interface Callable<T> {
    V call() throws Exception;
}

Callable接口显然不能直接作为Thread种的Runnable target来使用，需要一个适配的接口RunnableFuture
，这个接口既可以作为target使用，也可以获取线程返回值。

package java.util.concurrent;
@FunctionalInterface
public interface RunnableFuture<V> extends Runnable, Future<V> {
    void run();
}

Future接口提供了多个针对线程的功能：
1. 能够取消异步执行中的任务
2. 判断任务是否完成
3. 获取任务结果
package java.util.concurrent;
public interface Future<V> {
    boolean cancel(boolean mayInterruptRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;
}

get() 阻塞获取，可以超时获取，超时后抛异常。调用线程处理异常。

isDone() 任务执行结束，返回true

isCancelled() 任务完成前取消，返回true

RunnableFuture接口的默认实现类FutureTask

public class FutureTask<V> implements RunnableFuture<V> {
    private Callable<V> callable;
    private Object outcome;
    FutureTask(Callable callable) {
        this.callable = callable;
    }
    void run() {
        outcome = callable.call();
    }
    V get() {
        return outcome;
    }
}


import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;
public class T3 {
    public static void main(String[] args) {
        try {
            Inn inn = new Inn();
            FutureTask<Long> futureTask = new FutureTask<>(inn);
            Thread t1 = new Thread(futureTask, "thread-9527");
            t1.start();
            Thread.sleep(2000);
            System.out.println(Thread.currentThread().getName() + " do something");
            long res = futureTask.get();
            System.out.println("end...");
            System.out.println(res);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }

    static class Inn implements Callable<Long> {
        @Override
        public Long call() throws Exception {
            Long startTime = System.currentTimeMillis();
            System.out.println(Thread.currentThread().getName()+" start");
            Thread.sleep(1000);
            for (int i=0;i<10000000;i++) {
                int j = i+200;
            }
            long res = System.currentTimeMillis() - startTime;
            System.out.println(Thread.currentThread().getName()+" end");
            return res;
        }
    }
}
```
![aa](./image/FutureTask.PNG)

4. 线程池创建线程
线程的创建是有成本的，线程池可以做到复用和管理线程

静态工厂类Executors
线程池接口类ExecutorService
```java
ExecutorService pool = Executors.newFixedThreadPool(3);

package java.util.concurrent;
public interface ExecutorService extends Executor {
    <T> Future<T> submit(Callable<T> task);
    Future<?> submit(Runnable task);

    void execute(Runnable command);
}
```

线程的核心原理



# 2 CAS原理，弊端和规避措施；JUC原子类；JMM核心原理；内存可见性和volatile内存语义

# 3 JUC显式锁原理和使用

# 4 JUC容器类；JUC组件实现的核心组件AQS抽象同步器的原理


# 5 高并发设计模式的原理，使用


